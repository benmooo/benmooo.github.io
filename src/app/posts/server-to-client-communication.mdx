---
title: "Server-to-Client Communication"
description: "各种 Server-to-Client 通信技术的优缺点和适用场景"
date: "2024-12-19"
tags: ["实时通信", "消息推送", "Server-to-Client"]
image: "/server-client-communication.png"
draft: false
keywords:
  [
    "Server-to-Client",
    "实时通信",
    "WebSocket",
    "Server-Sent Events",
    "长轮询",
    "HTTP Streaming",
    "Webhooks",
    "聊天系统",
    "消息推送",
    "实时应用",
    "前端架构",
  ]
category: "Architecture"
readingTime: "16 min"
lastModified: "2024-12-19"
---

最近的dentflex项目打算做聊天和实时的消息推送的功能 在此记录总结下Server to Client communication相关的技术 用以加深理解并为技术选择做一些论据

在深入具体技术之前，我们的主要矛盾是：**HTTP 协议是请求-响应模式，服务器无法主动向客户端发送数据**。

$$
\text{Traditional HTTP}: \text{Client} \xrightarrow{\text{Request}} \text{Server} \xrightarrow{\text{Response}} \text{Client}
$$

但我们需要的是：

$$
\text{Real-time Communication}: \text{Server} \xrightarrow{\text{Data Push}} \text{Client}
$$

### Solutions

#### 1. 轮询 (Polling) / 短轮询 (Short Polling)

**原理**
客户端周期性地向服务器发送请求（例如，每隔几秒钟），询问是否有新的数据。

**优点**

- 实现简单，兼容性好（所有浏览器都支持）

**缺点**

- **效率低下**：大部分请求可能是无用的，增加了服务器的负担和网络流量
- **延迟**：数据更新的延迟取决于轮询间隔，间隔越长延迟越高
- **实时性差**：无法做到真正的实时推送

**适用场景**
对实时性要求不高，数据更新频率较低的场景，如获取新闻列表、订单状态等。

---

#### 2. 长轮询 (Long Polling)

**原理**
客户端向服务器发送请求后，服务器会保持连接打开，直到有新数据可用或者达到超时时间。一旦有新数据，服务器立即响应并关闭连接。客户端收到响应后，会立即发送新的请求以重新建立连接。

**优点**

- 比短轮询更高效，减少了无谓的请求，实时性相对更好

**缺点**

- **服务器资源占用**：连接在服务器端长时间保持打开，占用服务器资源
- **复杂性增加**：需要服务器端对连接进行管理，实现起来相对复杂
- **仍然存在延迟**：在数据到达和客户端收到响应之间可能仍有轻微延迟

**适用场景**
对实时性有一定要求，但又不至于需要毫秒级延迟的场景，如聊天室（早期的实现方式）、在线文档协作等。

---

#### 3. HTTP Streaming (流式传输 / HTTP Pipelining)

**原理**
客户端发起一个请求，服务器保持连接打开，并周期性地向客户端发送数据，而不是关闭连接。数据以"块"的形式传输。

**优点**

- 减少了重复建立连接的开销，实时性比轮询更好

**缺点**

- **数据解析复杂**：客户端需要能够处理分块传输的数据
- **服务器端实现复杂**：需要特殊的服务器配置和处理
- **中间代理问题**：某些代理服务器可能会缓存数据，导致延迟或中断

**适用场景**
数据持续不断地从服务器发送到客户端，如股票报价、日志流等。

---

#### 4. WebSocket

**原理**
在客户端和服务器之间建立一个持久化的、双向的通信通道。一旦建立，双方可以随时互相发送数据，而无需重复建立 HTTP 连接。

**优点**

- **全双工通信**：客户端和服务器可以同时发送和接收数据
- **低延迟**：建立连接后，数据传输效率高，延迟极低，真正实现实时通信
- **协议开销小**：相比 HTTP，WebSocket 的数据帧非常轻量

**缺点**

- **兼容性**：虽然现代浏览器支持良好，但对于老旧浏览器可能需要降级方案（如使用 SockJS 库）
- **服务器资源**：维持大量持久连接会占用服务器资源
- **代理问题**：需要代理服务器支持 WebSocket 协议升级

**适用场景**
几乎所有需要实时双向通信的场景，如在线聊天、多人游戏、实时协作、直播弹幕、股票实时行情等。

---

#### 5. Server-Sent Events (SSE)

**原理**
基于 HTTP 协议，客户端发起一个请求，服务器保持连接打开，并可以单向地持续向客户端推送数据。它是一种只支持服务器到客户端单向通信的流式技术。

**优点**

- **简单易用**：基于 HTTP 协议，比 WebSocket 更容易实现和部署
- **自动重连**：客户端（浏览器）提供了内置的 EventSource API，支持自动重连
- **协议开销小**：数据格式简单，通常是文本

**缺点**

- **单向通信**：客户端无法通过同一个连接向服务器发送数据（如果需要，仍需使用额外的 AJAX 或 WebSocket）
- **二进制数据支持差**：主要用于传输文本数据
- **连接数限制**：和 HTTP 连接一样，受限于浏览器对同一域名最大连接数的限制（通常是 6-8 个）

**适用场景**
服务器需要持续向客户端推送更新的场景，如新闻推送、股票报价、体育赛事实时比分、通知中心、在线日志输出等，且客户端无需向服务器频繁发送消息。

---

#### 6. Webhooks

Webhooks 不是一个客户端主动建立并保持的连接，而是一种"推"（Push）机制，由服务器发起，通常是服务器之间（Server-to-Server）的通信，但最终目的是通知客户端或更新客户端能访问到的数据。

##### Webhooks 的工作原理

1. **注册回调 URL**：客户端（通常是应用服务器，而不是直接的浏览器前端）在另一个服务（例如 GitHub、Stripe、Shopify 等）上注册一个公开可访问的 URL。这个 URL 就是"Webhook 端点"。

2. **事件触发**：当在那个服务上发生特定事件（如 GitHub 上的代码提交、Stripe 上的支付完成、Shopify 上的订单创建）时，该服务会向注册的 Webhook URL 发送一个 HTTP POST 请求。

3. **接收和处理**：应用服务器接收到这个 POST 请求，并解析请求体中的数据（通常是 JSON 格式），从而得知发生了什么事件及其相关信息。

4. **后续处理**：服务器根据接收到的事件数据进行相应的处理，例如：
   - 更新数据库
   - 触发内部逻辑

然后，如果我们需要将这个更新通知给最终用户（浏览器客户端），应用服务器会使用上面提到的某种"Server-to-Client communication"技术（如 WebSocket 或 SSE）来将信息推送到用户的浏览器。

Webhooks 本身是 Server-to-Server 的通知机制。但它常常作为更大系统架构的一部分，来支撑最终的 Server-to-Client 实时更新。
